https://github.com/jestan/kilim-maven-plugin/blob/master/src/main/java/io/kilimty/KilimWeaverMojo.java
https://github.com/kilim/kilim
http://www.ibm.com/developerworks/cn/java/j-javadev2-7.html
http://blog.csdn.net/kobejayandy/article/details/41412787


### 协程
<https://www.zhihu.com/question/20511233>

1. <b>线程确实比协程性能更好</b>。因为线程能利用多核达到真正的并行计算，如果任务设计的好，
线程能几乎成倍的提高你的计算能力，说线程性能不好的很多是因为没有设计好导致大量的锁、切换、等待，
这些很多都是应用层的问题。而协程因为是非抢占式，所以需要用户自己释放使用权来切换到其他协程，
因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力.
2. <b>协程性能好的，其实真正的原因是因为瓶颈在IO上面</b>
3. <b>协程的确可以减少callback的使用但是不能完全替换callback</b>。基于事件驱动的编程里面反而不能发挥协程的作用而用callback更适合。
4. <b>本质上协程就是用户空间下的线程。</b>
5. 通俗易懂的回答:让原来要使用异步+回调方式写的非人类代码,可以用看似同步的方式写出来...
6. 协程避免了操作系统切换线程的工作
7. 操作系统就是用C/C++写的。 C/C++能够直接调用系统接口。 你知道Java为什么要JVM才能跑吗？因为他不能直接调用系统接口。 
所以C/C++不需要虚拟机。 但是因为操作系统的不同，接口调用方式不同。所以C/C++不能跨平台。

---

#### 进程、线程和协程的理解
<http://blog.csdn.net/hairetz/article/details/16119911>

+ 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
+ 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
+ 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，
协程也失去了标准线程使用多CPU的能力。

<pre>
打个比方吧，假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，
而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，
假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。
如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。
如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。
</pre>

<pre>
有一个 GUI 程序，上面有两个按钮，一个 运算 一个 取消 ，点击运算，会有一个运算线程启动，不停的运算，点击取消，
会取消这个线程，如果使用 python 的内置线程或者标准线程，都是没有问题的，即便运算线程不停的运算，
调度器仍然会给 GUI 线程分配时间片，用户可以点击取消，然而，如果使用 gevent 包装后的线程就完蛋了，一旦运算开始，
GUI 就会失去相应，因为那个运算线程(协程)霸着 CPU 不让位。不单是 GUI ，所有和用户交互的程序都会有这个问题。
</pre>

#### 协程（Coroutine）并不是真正的多线程
<http://www.cnblogs.com/wonderKK/p/4062591.html>

#### Java中的协程
<https://segmentfault.com/a/1190000000666747>

#### 微信异步化改造实践：8亿月活、万台机器背后的解决方案(协程)
<http://mp.weixin.qq.com/s/7vFLHiynHdn6YD_5P_5T4g>
<https://github.com/tencent/libco>

<pre>
异步化改造方案的考量


当时我们有两种选择。

A 线程异步化：把所有服务改造成异步模型，等同于从框架到业务逻辑代码的彻底改造。

B 协程异步化：对业务逻辑非侵入的异步化改造，即只修该少量框架代码。

两者相比，工作量和风险系数的差异显而易见。虽然A方案服务器端多线程异步处理是常见做法，对提高并发能力这个原始目标非常奏效；但是对于微信后台如此复杂的系统，这过于耗时耗力且风险巨大。

无论是异步模型还是同步模型，都需要保存异步状态。所以两者在技术细节的相同点是，两个方案，都是需要维护当前请求的状态。在A异步模型中方案，当请求需要被异步执行时，需要主动把请求相关数据保存起来，再等待状态机的下一次调度执行；而在B协程模型方案中，异步状态的保存与恢复是自动的，协程恢复执行的时候就是上一次退出时的上下文。

因此，B协程方案不需要显式地维护异步状态：一方面在编程上可以更简单和直接；另一方面协程中只需要保存少量的寄存器。因此在复杂系统上，协程服务的性能可能比纯异步模型更优。

综合以上考虑，最终我们选择了B方案，通过协程的方式对微信后台上百个模块进行了异步化改造。


接管历史遗留的同步风格API


方案敲定之后，接下来做的就是实现异步化的同时尽可能地少做代码修改。

通常而言，一个常规的网络后台服务需要connect、write、read等系列步骤，如果使用同步风格的API对网络进行调用，整个服务线程会因为等待网络交互而挂起，这就会造成等待并占用资源。原来的这种情况很明显地影响到了系统的并发性能，但是当初这样的选择是因为对应的同步编程风格具有其独特的优势：代码逻辑清晰、易于编写并且支持业务快速迭代敏捷开发。

我们的改造方案需要消除同步风格API的缺点，但是同时还希望保持同步编程的优点。

最后在不修改线上已有的业务逻辑代码的情况下，我们的libco框架创新地接管了网络调用接口（Hook）。把协程的让出与恢复作为异步网络IO中的一次事件注册与回调。当业务处理遇到同步网络请求的时候，libco层会把本次网络请求注册为异步事件，当前的协程让出CPU占用，CPU交给其它协程执行。在网络事件发生或者超时的时候，libco会自动的恢复协程执行。

</pre>


#### java 协程
+ akka(Scala Actor),需要学习,写actor代码
 (Actor之间通过消息传递的方式来进行交互，而不采用共享的方式，Actor可以看做是一个轻量级的进程或线程，通常在一台4G内存的机器上，创建几十万个Actor是毫无问题的，Actor支持Continuations)
+ kilim,学习门槛更低,但对于需要采用coroutine方式执行的代码在编译完毕后，还需要采用Kilim的kilim.tools.Weaver类来对这些已编译出来的class文件做织入，运行时需要用织入后生成的class文件才行



#### 在Java中使用协程（Coroutine）!!!好文
<http://www.blogjava.net/BlueDavy/archive/2010/01/28/311148.html>

+ 现在的操作系统都是支持多任务的，多任务可通过多进程或多线程的方式去实现，进程和线程的对比就不在这里说了，在多任务的调度上操作系统采取抢占式和协作式两种方式，
抢占式是指操作系统给每个任务一定的执行时间片，在到达这个时间片后如任务仍然未释放对CPU的占用，那么操作系统将强制释放，
这是目前多数操作系统采取的方式；协作式是指操作系统按照任务的顺序来分配CPU，每个任务执行过程中除非其主动释放，
否则将一直占据CPU，这种方式非常值得注意的是一旦有任务占据CPU不放，会导致其他任务”饿死”的现象，因此操作系统确实不太适合采用这种方式。

+ 说完操作系统多任务的调度方式后，来看看通常程序是如何实现支持高并发的，一种就是典型的基于操作系统提供的多进程或多线程机制，
每个任务占据一个进程或一个线程，当任务中有IO等待等动作时，则将进程或线程放入待调度队列中，这种方式是目前大多数程序采取的方式，
这种方式的坏处在于如想支持高的并发量，就不得不创建很多的进程或线程，而进程和线程都是要消耗不少系统资源的，
另外一方面，进程或线程创建太多后，操作系统需要花费很多的时间在进程或线程的切换上，切换动作需要做状态保持和恢复，
这也会消耗掉很多的系统资源；<b>另外一种方式则是每个任务不完全占据一个进程或线程，当任务执行过程中需要进行IO等待等动作时，
任务则将其所占据的进程或线程释放，以便其他任务使用这个进程或线程，这种方式的好处在于可以减少所需要的原生的进程或线程数，
并且由于操作系统不需要做进程或线程的切换，而是自行来实现任务的切换，其成本会较操作系统切换低，
这种方式也就是本文的重点，Coroutine方式，又称协程方式，这种方式在目前的大多数语言中都有支持。</b>

+ 各种语言在实现Coroutine方式的支持时，多数都采用了Actor Model来实现，Actor Model简单来说就是每个任务就是一个Actor，
Actor之间通过消息传递的方式来进行交互，而不采用共享的方式，Actor可以看做是一个轻量级的进程或线程，通常在一台4G内存的机器上，
创建几十万个Actor是毫无问题的，Actor支持Continuations

