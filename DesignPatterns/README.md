DesignPatterns
==============

Design Patterns Demo 


These DEMO Mainly from these three sites：
http://www.cnblogs.com/java-my-life/
http://www.iteye.com/blogs/subjects/java_design_patterns
http://www.iteye.com/blogs/subjects/sjms
thanks .


设计模式就三个准则：1）中意于组合而不是继承，2）依赖于接口而不是实现，3）高内聚，低耦合。你看，这完全就是Unix的设计准则

---
史上最全设计模式导学目录:<http://blog.csdn.net/lovelion/article/details/17517213>
很多实例!!!

例子:<https://github.com/iluwatar/java-design-patterns>, <http://java-design-patterns.com/>

---

+ <https://mp.weixin.qq.com/s/licShpK5ry3tfczCiQDmGw> (好文!!!)
+ 设计模式分为三类，创建型，结构型和行为型。创建型比较好理解，它抽象了实例化过程，将系统与实例的创建解耦。实例由专门的工厂来创建，从而使系统针对实例的抽象接口编程，不依赖任何具体的实现。结构型和行为型有点难以理解，GoF的解释是，结构型模式涉及到如何组合类和对象以获得更大的结构；行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。
+ 大部分行为型和结构型设计模式的特点还是挺明显的，但是有少部分的界限就没那么清晰。比如说代理模式属于结构型模式，但是它也承担了职责的分配。它通过一个代理类，直接处理客户请求，但是把大部分实际职责交给原始的工作类。将设计模式划分为三种类型，可以理解为是划分出一种层级，帮助模式的使用者记忆和理解。

+ 适配器模式的目的是为了兼容新模块和老系统，而加入中间层做适配。而外观模式的目的是为了降低系统使用某个外接系统的成本和耦合。
+ !!! 设计模式的定义 --“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心”。也就是说设计模式是由两部分组成的，即它描述的问题以及解决方案。两个设计模式的解决方案可能是相同的，甚至可以说所有设计模式的解决方案都是相同的（添加中间层），但是所有设计模式描述的问题绝对是不相同的。
+ 享元模式会和简单工厂模式有点像，都用到了工厂的概念。其实享元模式里面就是用到了简单工厂模式来管理细粒度对象。享元模式解决的问题是对象的共享，而工厂模式解决的问题是如何封装对象的创建过程。明白它们两解决的问题，就知道它们是两种完全不一样的模式。但是它们却可以完美地结合在一起，协同解决问题。
+ 适配器模式和代理模式非常相似。它们都将一个模块进行了一次封装，从而为系统访问提供便利，保证系统不需要改变调用接口就可以增强功能。适配器模式和代理模式最大的不同还是在于他们的出发点不同，适配器模式是为了做兼容，而代理模式的核心是增加功能。当然适配器模式在做适配的时候，也可以增加一些功能，这样它就跟代理模式非常接近了。
+ 命令模式的类图和适配器模式的类图很像，它们做的事情都是制造了一个中间层，提供给系统统一的调用接口，封装了真正干活的实体。它们的差异还是在于使用意图，命令模式是为了命令的复用和灵活切换，而适配器模式是为了在新旧接口之间做兼容。
+ 装饰模式和组合模式存在很大的相似程度。它们都是通过组合的方式将对象组织在一起，然后通过递归的方式去访问以实现功能。如果组合模式中每个节点只维护一个子节点的话，它就与装饰模式基本无异了，也即是说装饰模式是一个退化了的组合模式。
  

