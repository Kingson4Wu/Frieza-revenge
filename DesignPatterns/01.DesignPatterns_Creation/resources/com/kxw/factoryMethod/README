   工厂方法模式(Factory Method)又称虚拟构造子模式，可以说是简单工厂的抽象，也可以理解为简单工厂是退化了的工厂方法模式，其表现在简单工厂丧失了工厂方法的多态性。
   我们前一节中提到当产品结构变的复杂的时候，简单工厂就变的难以应付，如果增加一种产品，核心工厂类必须改动，使得整个工厂的可扩展性变得很差，对开闭原则支持不够。
   工厂方法模式克服了这些缺点，它定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，
   仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。一般结构图如下：


工厂方法模式的对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不在负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。
在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。

    工厂方法模式有如下角色：
    
    抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
    具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。
    在上图中有两个这样的角色：BulbCreator与TubeCreator。
    抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。在上图中，这个角色是Light。
    具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。
    实例：延续上节中例子来讲，上节中我们提到造车工厂会造拖拉机，汽车，火车，在一个工厂里明显不能完成，在现实世界中，一定是有自己独立的工厂来做。
    因为我们知道拖拉机，汽车，火车有很多共性也有很大差异，共性还是车，肯定都是重工生产，需要钢材，车床加工，都需要动力，都有座椅，车灯等等，那差异就多了，
    动力不同，火车可能是电动力，汽车是汽油，拖拉机是柴油等等。我们利用工厂方法来抽象这个造车工厂的模型如下：
    
   通过以上模型可以看出，工厂方法模式是把原来简单工厂里创建对象的过程延迟到了具体实现的子类工厂，这时的工厂从一个类变成了一个接口类型。
        
        