　　装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

装饰模式的结构
　　装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。

　　装饰模式的类图如下：

　　

　　在装饰模式中的角色有：

　　●　　抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。

　　●　　具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。

　　●　　装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。

　　●　　具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。

---------------------

装饰模式使用被装饰类的一个子类的实例，把客户端的调用委派到被装饰类，装饰模式的关键在于这种扩展是完全透明的。
 
装饰模式在Java种使用也很广泛，比如我们在重新定义按钮、对话框等时候，实际上已经在使用装饰模式了。装饰模式最浅显的例子是相片-相框的例子。
 
一、原理图

其中类的职责如下：
 
抽象构件角色（Project）：给出一个接口，以规范准备接收附加责任的对象
具体构件角色（Employe）：定义一个将要接收附加责任的类
装饰角色（Manager）：持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口
具体装饰角色（ManagerA、ManagerB）：负责给构件对象“贴上”附加的责任
 
二、下面通过一个软件项目例子来说明装饰模式的使用
过程是这样的：
项目经理接到一个项目，项目最终要完成编码。
项目经理接到项目后，先做些前期的工作（比如需求分析、设计），然后将编码工作委派给代码工人，代码工人干完后，项目经理做项目的收尾工作。


运行结果：
项目经理A 在做需求分析 
项目经理A 在做架构设计 
项目经理A 在做详细设计 
代码工人 在编写代码，加班编啊编啊，终于编完了！ 
项目经理B 在做需求分析 
项目经理B 在做详细设计 
代码工人 在编写代码，加班编啊编啊，终于编完了！ 
项目经理B 在做收尾工作 

Process finished with exit code 0

——— ——— ——— ———— ——— —————— —— —— —— — —— ————— ————— ———— ———— ——— ————
http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html
http://blog.csdn.net/kingson_wu/article/details/38383285



