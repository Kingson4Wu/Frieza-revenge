桥梁（Bridge）模式：又称Handle/Body。将抽象部分和实现部分分离，使它们都可以独立的变化。桥梁模式属于对象的结构模式。
GOF桥梁模式的示意性结构类图如下：

通过上图可以看出桥梁模式有以下角色：
抽象化（Abstraction）角色：给出抽象化定义并持有一个实现化对象的引用。
修正抽象化（Refined Abstraction）角色：扩展抽象化角色，改变和修正父类对抽象化的定义。
实现化（Implementor）角色：给出实现化的接口角色的接口，但不给出具体的实现。
具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。
 
桥梁模式在于将抽象和实现分离（也就是我们常说的解耦），让抽象和实现能够独立变化。来举个例子：抽象的车，有火车和汽车，而火车有客车和火车，也就是能运货物和人；
汽车也是如此，能运货物和运客人。我们可以如下建立模型：
 
这种模式将车的属性和行为分类，让车 和运输相互独立演变，类的数量由原来的M*N变成M+N的数量，利用组合方式代替继承，这也符合‘组合聚合复用原则’，
组合聚合复用原则讲的是要尽可能使用组合、聚合来达到复用目的而不是利用继承。对于增加一个运输方式或者增加一个车的种类，直接添加即可，不必修改其他类，
也只需修改一处即可。
上述描述代码如下：
 

这种模式将车的属性和行为分类，让车 和运输相互独立演变，类的数量由原来的M*N变成M+N的数量，利用组合方式代替继承，这也符合‘组合聚合复用原则’，
组合聚合复用原则讲的是要尽可能使用组合、聚合来达到复用目的而不是利用继承。对于增加一个运输方式或者增加一个车的种类，直接添加即可，不必修改其他类，也只需修改一处即可。

运行结果如下：
火车运货
火车运客
汽车运货
汽车运客
通过上面代码可以看出，桥梁模式有如下优点：
1、分离接口及实现部分  一个实现不必一直绑定在一个接口上；
2、提高可扩充性，使扩展变得简单

——— ————— —————— ——— ——————— —————— ——————
(跟抽象工厂对比一下-------------------)
可以看一下测试代码进行对比，比较明显
———— ———— ———— ——— ———— ———— ————— ———— ———