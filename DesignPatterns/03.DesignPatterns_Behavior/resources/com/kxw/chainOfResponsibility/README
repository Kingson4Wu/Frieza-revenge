责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。
发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任
 
我的理解是：消息在链上不断的传递，直到遇到一个可以处理此消息的处理器，【这个处理器在链上】
或者说，消息本身带有等级，每一个处理器只能处理相应等级的消息。只有消息可以被处理的时候，不会在链上传播，否则这个消息会在链上一直传播.
 
责任链模式涉及到的角色如下所示：
●抽象处理者(Handler)角色：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。
上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。
●具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，
因此，如果需要，具体处理者可以访问下家。
 
 
Example: 测试人员针对于当前测试的系统会提一些bug,当bug等级为低的时候初级程序员就可以修复
                    等级为中等的时候需要中级程序员来修复，等缓为高级的时候就需要强力大牛来解决，我们
                    通过责任链来实现这一功能
                    
                    
         结果：
       
bug等级为低级，初级程序员可以完成
------------------------
bug等级太高，初级程序员处理不了，给中级程序员
bug等级中级，中级程序员可以完成
------------------------
------------------------
bug等级太高，初级程序员处理不了，给中级程序员
bug等级太高，中级程序员处理不了，给高级程序员
bug等级高级，大牛亲自出马
------------------------
------------------------
bug等级太高，初级程序员处理不了，给中级程序员
bug等级太高，中级程序员处理不了，给高级程序员
bug太严重了，大牛也处理不了
------------------------
------------------------
 
补：
纯的与不纯的责任链模式
一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。
 
在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。
 
纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。有些人认为不纯的责任链根本不是责任链模式，这也许是有道理的。
但是在实际的系统里，纯的责任链很难找到。如果坚持责任链不纯便不是责任链模式，那么责任链模式便不会有太大意义了。           



------------------------------------------------------------------------

举这样一个例子，在玩具工厂的生产车间，流水线就是一条责任链，假如一个玩具飞机有外壳装配员，引擎装配员，螺旋桨装配员，模型包装员组成。当这个物件飞机流到谁那里，
谁就负责安装他负责的这一部分，这部分安装完成后流到下一个环节，知道所有环境完成。这个是一生成的责任链。还有一个质量检测链，质量检测也分多部，外壳检测，引擎检测，
螺旋桨检测，包装检测。当产品留到检测员那里检测自己负责的那一块，如果有问题直接拎出来，如果没问题则传给下一个检测员，直到所有检测完成。这两个都是责任链，但是区别是，
生成责任链每个人都会处理，并处理一部分；而质量检测责任链经过判断，要么处理掉，要么不处理流下去。这就是责任链的两种分类，后一种叫做纯的责任链，前一种叫做不纯的责任链，
纯的责任链在实际应用中很少存在，常见的为不纯的责任链，上面的模型是模拟纯的责任链来处理的。
 
责任链模式在现实中使用的很多，常见的就是OA系统中的工作流。 在java中的实际应用有Servlet中的过滤器（Filter），Struts2的拦截器（Interceptor）。
Struts2本身在Servlet中也是以Filter的形式出现的，所以Struts2的结构图中，也可以明显看出Filter和Interceptor这两条链的存在。



可以看出它们每个节点都可以做一些事情，所以不算一个纯的责任链。
在上面提到了OA系统，那么我们再模拟一下OA系统中请假审批流程，假如员工直接上司为小组长，小组长直接上司项目经理，项目经理直接上司部门经理，部门经理直接上司总经理。
公司规定请假审批如下：
请假时间为t,时间单位day，简写d：
t<  0.5d，小组长审批；
t>=0.5d,t<2,项目经理审批；
t>=2,t<5部门经理审批；
t>=5总经理审批；



 运行结果：
小组长传给了他的上司
项目经理传给了他的上司
部门经理审批通过
 
这里模拟的是一个理想的状态，所以是一个纯的责任链；在实际当中，可能小组长签字，项目经理签字...一堆的签字，而不是不参与请求的处理。
责任链模式的优点是调用者不需知道具体谁来处理请求，也不知道链的具体结构，降低了节点域节点的耦合度；可在运行时动态修改链中的对象职责，增强了给对象指派职责的灵活性；
缺点是没有明确的接收者，可能传到链的最后，也没得到正确的处理。

