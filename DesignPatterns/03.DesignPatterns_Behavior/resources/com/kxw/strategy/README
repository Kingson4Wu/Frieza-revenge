策略（Strategy）模式：又名Policy，它的用意是定义一组算法，把它们一个个封装起来，并且使他们可以相互替换。策略模式可以独立于使用他们的客户端而变化。
GOF策略模式静态结构类图如下：

通过上图可以看出策略模式有以下角色构成：
1、抽象策略（Strategy）角色：抽象策略角色由抽象类或接口来承担，它给出具体策略角色需要实现的接口；
2、具体策略（ConcreteStrategy）角色：实现封装了具体的算法或行为；
3、场景（Context）角色：持有抽象策略类的引用。
策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对扩展开放对修改关闭。
策略模式在新的策略增加时，不会影响其他类的修改，增加了扩展性，也就是对扩展是开放的；对于场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。策略模式的认识可以借助《java与模式》一书中写到诸葛亮的锦囊妙计来学习，在不同的场景下赵云打开不同的锦囊，便化险为夷，锦囊便是抽象策略，具体的锦囊里面的计策便是具体的策略角色，场景就是赵云，变化的处境
选择具体策略的条件。
 
策略模式在程序设计中也很常用，在板桥（banq）的博客里有篇文章叫 “你还在用if else吗？”
“http://www.jdon.com/artichect/ifelse.htm”讲的很好，策略模式不但是继承的代替方案而且能很好地解决if else问题，下面举个实例来说明，
怎么使用策略模式。
需求如下：
某支付系统接入以下几种商户进行充值：易宝网易，快线网银，19pay手机支付，支付宝支付，骏网一卡通，由于每家充值系统的结算比例不一样，
而且同一家商户的不同充值方式也有所不同，具体系统情况比较复杂，像支付宝既有支付宝账号支付和支付宝网银支付等这些暂时不考虑，
为了讲述策略模式这里简单描述，假如分为四种，手机支付，网银支付，商户账号支付和点卡支付。因为没个支付结算比例不同，所以对手续费低的做一些优惠活动，
尽可能让用户使用手续费低的支付方式来充值，这样降低渠道费用，增加收入，具体优惠政策如下：
①网银充值，8.5折；
②商户充值，9折；
③手机充值，没有优惠；
④点卡充值，收取1%的渠道费；
对于一个新手的代码如下：



运行结果：
 
85.0
90.0
100.0
101.0
从上面类图和代码可以看出，策略模式把具体的算法封装到了具体策略角色内部，增强了可扩展性，隐蔽了实现细节；它替代继承来实现，
避免了if-else这种不易维护的条件语句。当然我们也可以看到，策略模式由于独立策略实现，使得系统内增加了很多策略类；
对客户端来说必须知道兜友哪些具体策略，而且需要知道选择具体策略的条件。




